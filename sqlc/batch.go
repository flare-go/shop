// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: batch.go

package sqlc

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const addOrderItems = `-- name: AddOrderItems :batchexec
INSERT INTO order_items (order_id, product_id, price_id, stock_id, quantity, unit_price, subtotal)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type AddOrderItemsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type AddOrderItemsParams struct {
	OrderID   int32   `json:"orderId"`
	ProductID string  `json:"productId"`
	PriceID   string  `json:"priceId"`
	StockID   uint64  `json:"stockId"`
	Quantity  uint64  `json:"quantity"`
	UnitPrice float64 `json:"unitPrice"`
	Subtotal  float64 `json:"subtotal"`
}

func (q *Queries) AddOrderItems(ctx context.Context, arg []AddOrderItemsParams) *AddOrderItemsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OrderID,
			a.ProductID,
			a.PriceID,
			a.StockID,
			a.Quantity,
			a.UnitPrice,
			a.Subtotal,
		}
		batch.Queue(addOrderItems, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &AddOrderItemsBatchResults{br, len(arg), false}
}

func (b *AddOrderItemsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *AddOrderItemsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const adjustStock = `-- name: AdjustStock :batchexec
UPDATE stocks
SET reserved_quantity = reserved_quantity + $2, updated_at = NOW()
WHERE id = $1 AND updated_at = $3
`

type AdjustStockBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type AdjustStockParams struct {
	ID               int32              `json:"id"`
	ReservedQuantity int32              `json:"reservedQuantity"`
	UpdatedAt        pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) AdjustStock(ctx context.Context, arg []AdjustStockParams) *AdjustStockBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.ReservedQuantity,
			a.UpdatedAt,
		}
		batch.Queue(adjustStock, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &AdjustStockBatchResults{br, len(arg), false}
}

func (b *AdjustStockBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *AdjustStockBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createStockMovement = `-- name: CreateStockMovement :batchexec
INSERT INTO stock_movements (stock_id, quantity, type, reference_id, reference_type, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
`

type CreateStockMovementBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateStockMovementParams struct {
	StockID       uint64                         `json:"stockId"`
	Quantity      uint64                         `json:"quantity"`
	Type          StockMovementType              `json:"type"`
	ReferenceID   *int32                         `json:"referenceId"`
	ReferenceType NullStockMovementReferenceType `json:"referenceType"`
}

func (q *Queries) CreateStockMovement(ctx context.Context, arg []CreateStockMovementParams) *CreateStockMovementBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.StockID,
			a.Quantity,
			a.Type,
			a.ReferenceID,
			a.ReferenceType,
		}
		batch.Queue(createStockMovement, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateStockMovementBatchResults{br, len(arg), false}
}

func (b *CreateStockMovementBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateStockMovementBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const reduceStock = `-- name: ReduceStock :batchexec
UPDATE stocks
SET quantity = quantity - $2, reserved_quantity = reserved_quantity - $2, updated_at = NOW()
WHERE id = $1 AND updated_at = $3
`

type ReduceStockBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type ReduceStockParams struct {
	ID        int32              `json:"id"`
	Quantity  uint64             `json:"quantity"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) ReduceStock(ctx context.Context, arg []ReduceStockParams) *ReduceStockBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.Quantity,
			a.UpdatedAt,
		}
		batch.Queue(reduceStock, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &ReduceStockBatchResults{br, len(arg), false}
}

func (b *ReduceStockBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *ReduceStockBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const releaseStock = `-- name: ReleaseStock :batchexec
UPDATE stocks
SET reserved_quantity = reserved_quantity - $2, updated_at = NOW()
WHERE id = $1 AND updated_at = $3
`

type ReleaseStockBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type ReleaseStockParams struct {
	ID               int32              `json:"id"`
	ReservedQuantity int32              `json:"reservedQuantity"`
	UpdatedAt        pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) ReleaseStock(ctx context.Context, arg []ReleaseStockParams) *ReleaseStockBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.ReservedQuantity,
			a.UpdatedAt,
		}
		batch.Queue(releaseStock, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &ReleaseStockBatchResults{br, len(arg), false}
}

func (b *ReleaseStockBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *ReleaseStockBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
