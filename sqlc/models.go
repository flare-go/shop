// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type CartStatus string

const (
	CartStatusActive    CartStatus = "active"
	CartStatusAbandoned CartStatus = "abandoned"
	CartStatusConverted CartStatus = "converted"
)

func (e *CartStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CartStatus(s)
	case string:
		*e = CartStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CartStatus: %T", src)
	}
	return nil
}

type NullCartStatus struct {
	CartStatus CartStatus `json:"cartStatus"`
	Valid      bool       `json:"valid"` // Valid is true if CartStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCartStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CartStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CartStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCartStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CartStatus), nil
}

func (e CartStatus) Valid() bool {
	switch e {
	case CartStatusActive,
		CartStatusAbandoned,
		CartStatusConverted:
		return true
	}
	return false
}

type OrderStatus string

const (
	OrderStatusPending    OrderStatus = "pending"
	OrderStatusProcessing OrderStatus = "processing"
	OrderStatusCompleted  OrderStatus = "completed"
	OrderStatusCancelled  OrderStatus = "cancelled"
	OrderStatusRefunded   OrderStatus = "refunded"
)

func (e *OrderStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderStatus(s)
	case string:
		*e = OrderStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderStatus: %T", src)
	}
	return nil
}

type NullOrderStatus struct {
	OrderStatus OrderStatus `json:"orderStatus"`
	Valid       bool        `json:"valid"` // Valid is true if OrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OrderStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderStatus), nil
}

func (e OrderStatus) Valid() bool {
	switch e {
	case OrderStatusPending,
		OrderStatusProcessing,
		OrderStatusCompleted,
		OrderStatusCancelled,
		OrderStatusRefunded:
		return true
	}
	return false
}

type StockMovementReferenceType string

const (
	StockMovementReferenceTypeOrder      StockMovementReferenceType = "order"
	StockMovementReferenceTypeReturn     StockMovementReferenceType = "return"
	StockMovementReferenceTypeAdjustment StockMovementReferenceType = "adjustment"
	StockMovementReferenceTypeCart       StockMovementReferenceType = "cart"
)

func (e *StockMovementReferenceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StockMovementReferenceType(s)
	case string:
		*e = StockMovementReferenceType(s)
	default:
		return fmt.Errorf("unsupported scan type for StockMovementReferenceType: %T", src)
	}
	return nil
}

type NullStockMovementReferenceType struct {
	StockMovementReferenceType StockMovementReferenceType `json:"stockMovementReferenceType"`
	Valid                      bool                       `json:"valid"` // Valid is true if StockMovementReferenceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStockMovementReferenceType) Scan(value interface{}) error {
	if value == nil {
		ns.StockMovementReferenceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StockMovementReferenceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStockMovementReferenceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StockMovementReferenceType), nil
}

func (e StockMovementReferenceType) Valid() bool {
	switch e {
	case StockMovementReferenceTypeOrder,
		StockMovementReferenceTypeReturn,
		StockMovementReferenceTypeAdjustment,
		StockMovementReferenceTypeCart:
		return true
	}
	return false
}

type StockMovementType string

const (
	StockMovementTypeIn      StockMovementType = "in"
	StockMovementTypeOut     StockMovementType = "out"
	StockMovementTypeReserve StockMovementType = "reserve"
	StockMovementTypeRelease StockMovementType = "release"
)

func (e *StockMovementType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StockMovementType(s)
	case string:
		*e = StockMovementType(s)
	default:
		return fmt.Errorf("unsupported scan type for StockMovementType: %T", src)
	}
	return nil
}

type NullStockMovementType struct {
	StockMovementType StockMovementType `json:"stockMovementType"`
	Valid             bool              `json:"valid"` // Valid is true if StockMovementType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStockMovementType) Scan(value interface{}) error {
	if value == nil {
		ns.StockMovementType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StockMovementType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStockMovementType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StockMovementType), nil
}

func (e StockMovementType) Valid() bool {
	switch e {
	case StockMovementTypeIn,
		StockMovementTypeOut,
		StockMovementTypeReserve,
		StockMovementTypeRelease:
		return true
	}
	return false
}

type Cart struct {
	ID         uint32             `json:"id"`
	CustomerID string             `json:"customerId"`
	Status     CartStatus         `json:"status"`
	Currency   interface{}        `json:"currency"`
	Subtotal   pgtype.Numeric     `json:"subtotal"`
	Tax        pgtype.Numeric     `json:"tax"`
	Discount   pgtype.Numeric     `json:"discount"`
	Total      pgtype.Numeric     `json:"total"`
	CreatedAt  pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt  pgtype.Timestamptz `json:"updatedAt"`
	ExpiresAt  pgtype.Timestamptz `json:"expiresAt"`
}

type CartItem struct {
	ID        uint32             `json:"id"`
	CartID    int32              `json:"cartId"`
	ProductID string             `json:"productId"`
	PriceID   string             `json:"priceId"`
	StockID   *int32             `json:"stockId"`
	Quantity  int32              `json:"quantity"`
	UnitPrice pgtype.Numeric     `json:"unitPrice"`
	Subtotal  pgtype.Numeric     `json:"subtotal"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
}

type Category struct {
	ID          uint32             `json:"id"`
	Name        string             `json:"name"`
	Description *string            `json:"description"`
	ParentID    *int32             `json:"parentId"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
}

type Order struct {
	ID              uint32             `json:"id"`
	CustomerID      string             `json:"customerId"`
	CartID          *int32             `json:"cartId"`
	Status          OrderStatus        `json:"status"`
	Currency        interface{}        `json:"currency"`
	Subtotal        pgtype.Numeric     `json:"subtotal"`
	Tax             pgtype.Numeric     `json:"tax"`
	Discount        pgtype.Numeric     `json:"discount"`
	Total           pgtype.Numeric     `json:"total"`
	PaymentIntentID *string            `json:"paymentIntentId"`
	ShippingAddress []byte             `json:"shippingAddress"`
	BillingAddress  []byte             `json:"billingAddress"`
	CreatedAt       pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz `json:"updatedAt"`
}

type OrderItem struct {
	ID        uint32             `json:"id"`
	OrderID   int32              `json:"orderId"`
	ProductID string             `json:"productId"`
	PriceID   string             `json:"priceId"`
	StockID   *int32             `json:"stockId"`
	Quantity  int32              `json:"quantity"`
	UnitPrice pgtype.Numeric     `json:"unitPrice"`
	Subtotal  pgtype.Numeric     `json:"subtotal"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
}

type ProductCategory struct {
	ProductID  string             `json:"productId"`
	CategoryID int32              `json:"categoryId"`
	CreatedAt  pgtype.Timestamptz `json:"createdAt"`
}

type Stock struct {
	ID               uint32             `json:"id"`
	ProductID        string             `json:"productId"`
	Quantity         int32              `json:"quantity"`
	ReservedQuantity int32              `json:"reservedQuantity"`
	Location         *string            `json:"location"`
	CreatedAt        pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz `json:"updatedAt"`
}

type StockMovement struct {
	ID            uint32                         `json:"id"`
	StockID       int32                          `json:"stockId"`
	Quantity      int32                          `json:"quantity"`
	Type          StockMovementType              `json:"type"`
	ReferenceID   *int32                         `json:"referenceId"`
	ReferenceType NullStockMovementReferenceType `json:"referenceType"`
	CreatedAt     pgtype.Timestamptz             `json:"createdAt"`
}
